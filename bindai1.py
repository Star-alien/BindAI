# -*- coding: utf-8 -*-
"""bindai1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uHro3mGnBZ9zuTNdL6YE4bjFBR2NJWwT
"""

pip install torch torchvision torchaudio biopython rdkit requests

!pip install biopython rdkit-pypi nglview

# Import libraries
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.layers import Input, concatenate
from Bio.PDB import PDBList, PDBParser
from rdkit import Chem
from rdkit.Chem import AllChem
import os

# Function to fetch protein structure data from PDB using NCBI API
def fetch_protein_data(pdb_id):
    pdb_dir = './pdb_files'
    if not os.path.exists(pdb_dir):
        os.makedirs(pdb_dir)

    pdbl = PDBList()
    pdbl.retrieve_pdb_file(pdb_id, pdir=pdb_dir, file_format="pdb")

    parser = PDBParser(QUIET=True)
    structure = parser.get_structure(pdb_id, os.path.join(pdb_dir, f'pdb{pdb_id.lower()}.ent'))
    return structure

# Function to convert protein structure into voxel grids
def voxelize_protein(structure, grid_size=32, grid_spacing=1.0):
    # Initialize empty grid
    grid = np.zeros((grid_size, grid_size, grid_size))

    # Calculate center of mass to center the grid
    atom_coords = np.array([atom.get_coord() for atom in structure.get_atoms()])
    com = np.mean(atom_coords, axis=0)

    # Shift coordinates to center
    shifted_coords = atom_coords - com

    # Scale coordinates to fit the grid
    max_coord = np.max(np.abs(shifted_coords))
    scale = (grid_size / 2 - 1) / max_coord
    scaled_coords = shifted_coords * scale

    # Convert to grid indices
    indices = ((scaled_coords + grid_size / 2)).astype(int)

    # Populate grid
    for idx in indices:
        x, y, z = idx
        if 0 <= x < grid_size and 0 <= y < grid_size and 0 <= z < grid_size:
            grid[x, y, z] = 1.0  # Mark atom presence

    return grid

# Function to generate molecular fingerprints from SMILES
def generate_fingerprint(smiles, n_bits=2048):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=n_bits)
        arr = np.zeros((1,), dtype=int)
        DataStructs.ConvertToNumpyArray(fp, arr)
        return arr
    else:
        print(f"Invalid SMILES string: {smiles}")
        return np.zeros((n_bits,), dtype=int)

# Build the CNN model with drug input
def build_cnn_with_drug_input(protein_input_shape, drug_input_shape):
    # Protein input and CNN layers
    protein_input = Input(shape=protein_input_shape)
    x = layers.Conv3D(32, (3, 3, 3), activation='relu')(protein_input)
    x = layers.MaxPooling3D((2, 2, 2))(x)
    x = layers.Conv3D(64, (3, 3, 3), activation='relu')(x)
    x = layers.MaxPooling3D((2, 2, 2))(x)
    x = layers.Conv3D(128, (3, 3, 3), activation='relu')(x)
    x = layers.GlobalMaxPooling3D()(x)

    # Drug input and dense layers
    drug_input = Input(shape=(drug_input_shape,))
    drug_layer = layers.Dense(256, activation='relu')(drug_input)
    drug_layer = layers.Dense(128, activation='relu')(drug_layer)

    # Concatenate protein and drug layers
    combined = concatenate([x, drug_layer])

    # Final layers
    combined = layers.Dense(256, activation='relu')(combined)
    combined = layers.Dense(128, activation='relu')(combined)
    output = layers.Dense(1, activation='sigmoid')(combined)

    # Build model
    model = models.Model(inputs=[protein_input, drug_input], outputs=output)
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Example usage with multiple proteins and drugs

# List of protein PDB IDs
pdb_ids = ['1A2C', '1A2B', '1A4U']  # Replace with actual PDB IDs

# Corresponding SMILES strings for drugs
drug_smiles_list = [
    'CCO',          # Ethanol
    'CC(=O)O',      # Acetic acid
    'C1CCCCC1'      # Cyclohexane
]

# Fetch and voxelize multiple protein structures
protein_structures = []
for pdb_id in pdb_ids:
    try:
        structure = fetch_protein_data(pdb_id)
        protein_structures.append(structure)
    except Exception as e:
        print(f"Error fetching protein {pdb_id}: {e}")

# Voxelize proteins
voxel_grids = [voxelize_protein(structure) for structure in protein_structures]

# Convert voxel grids to NumPy arrays
X_proteins = np.array(voxel_grids).reshape(-1, 32, 32, 32, 1)

# Generate drug fingerprints
from rdkit import DataStructs

drug_fingerprints = []
for smiles in drug_smiles_list:
    fp = generate_fingerprint(smiles)
    drug_fingerprints.append(fp)

X_drugs = np.array(drug_fingerprints)

# Example labels (1 for binding, 0 for non-binding)
y_train = np.array([1, 0, 1])  # Replace with actual binding affinity labels

# Build the CNN model
protein_input_shape = (32, 32, 32, 1)  # Shape of the protein voxel grid
drug_input_shape = X_drugs.shape[1]    # Length of drug fingerprint vector
cnn_drug_model = build_cnn_with_drug_input(protein_input_shape, drug_input_shape)

# Train the model
cnn_drug_model.fit([X_proteins, X_drugs], y_train, epochs=10, batch_size=1)

# Predict for new protein-drug pair
new_pdb_id = '1A2C'  # Replace with a new PDB ID
new_smiles = 'CCN'   # Example SMILES string (Ethylamine)

# Fetch and voxelize new protein
new_structure = fetch_protein_data(new_pdb_id)
new_protein_voxel = voxelize_protein(new_structure)
new_protein_voxel = new_protein_voxel.reshape(1, 32, 32, 32, 1)

# Generate fingerprint for new drug
new_drug_fp = generate_fingerprint(new_smiles).reshape(1, -1)

# Predict binding probability
prediction = cnn_drug_model.predict([new_protein_voxel, new_drug_fp])
print(f'Predicted binding site probability for new protein-drug pair: {prediction[0][0]}')
# Save the trained model
cnn_drug_model.save('deepdrug1st.keras')  # Save your trained model

# Loading the model (optional, for later use)
from tensorflow.keras.models import load_model

# Load the model
model = load_model('deepdrug1st.keras')  # Ensure this is the correct path

import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras import layers, models
from tensorflow.keras.layers import Input, concatenate
from rdkit import Chem
from rdkit.Chem import AllChem
from Bio.PDB import PDBList, PDBParser
import os

# Function to voxelize the protein structure
def voxelize_protein(pdb_file, voxel_size=1.0):
    parser = PDBParser()
    structure = parser.get_structure('protein', pdb_file)

    # Extract atom positions
    atom_positions = []
    for model in structure:
        for chain in model:
            for residue in chain:
                for atom in residue:
                    atom_positions.append(atom.coord)

    # Create a 3D grid (voxel representation)
    x_max = max(atom_positions, key=lambda x: x[0])[0]
    y_max = max(atom_positions, key=lambda x: x[1])[1]
    z_max = max(atom_positions, key=lambda x: x[2])[2]

    grid_size = (int(x_max / voxel_size) + 1, int(y_max / voxel_size) + 1, int(z_max / voxel_size) + 1)
    voxel_grid = np.zeros(grid_size)

    for pos in atom_positions:
        x_idx = int(pos[0] / voxel_size)
        y_idx = int(pos[1] / voxel_size)
        z_idx = int(pos[2] / voxel_size)
        voxel_grid[x_idx, y_idx, z_idx] = 1  # Mark the voxel as occupied

    return voxel_grid

# Function to generate molecular features from SMILES
def generate_molecular_features(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        raise ValueError("Invalid SMILES string")
    # Generate molecular fingerprints
    fingerprint = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
    return np.array(fingerprint)

# Function to predict interaction
def predict_interaction(protein_voxel, drug_features, model):
    protein_input = np.expand_dims(protein_voxel, axis=0)  # Expand dims for batch size
    drug_input = np.expand_dims(drug_features, axis=0)  # Expand dims for batch size
    prediction = model.predict([protein_input, drug_input])
    return prediction

# Load the model
model = load_model('deepdrug1st.keras')

# User input for protein and drug
def user_input_interaction_check():
    pdb_file = input("Enter the path to the protein PDB file: ")
    smiles = input("Enter the SMILES representation of the drug: ")

    # Voxelize the protein
    protein_voxel = voxelize_protein(pdb_file)

    # Generate molecular features
    try:
        drug_features = generate_molecular_features(smiles)
    except ValueError as e:
        print(e)
        return

    # Predict interaction
    prediction = predict_interaction(protein_voxel, drug_features, model)
    print(f"Predicted interaction score: {prediction[0][0]}")

# Run the interaction check
user_input_interaction_check()

# Import libraries
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.layers import Input, concatenate
from Bio.PDB import PDBList, PDBParser
from rdkit import Chem
from rdkit.Chem import AllChem
import os

# Function to fetch protein structure data from PDB using NCBI API
def fetch_protein_data(pdb_id):
    pdb_dir = './pdb_files'
    if not os.path.exists(pdb_dir):
        os.makedirs(pdb_dir)

    pdbl = PDBList()
    pdbl.retrieve_pdb_file(pdb_id, pdir=pdb_dir, file_format="pdb")

    parser = PDBParser(QUIET=True)
    structure = parser.get_structure(pdb_id, os.path.join(pdb_dir, f'pdb{pdb_id.lower()}.ent'))
    return structure

# Function to convert protein structure into voxel grids
def voxelize_protein(structure, grid_size=32, grid_spacing=1.0):
    # Initialize empty grid
    grid = np.zeros((grid_size, grid_size, grid_size))

    # Calculate center of mass to center the grid
    atom_coords = np.array([atom.get_coord() for atom in structure.get_atoms()])
    com = np.mean(atom_coords, axis=0)

    # Shift coordinates to center
    shifted_coords = atom_coords - com

    # Scale coordinates to fit the grid
    max_coord = np.max(np.abs(shifted_coords))
    scale = (grid_size / 2 - 1) / max_coord
    scaled_coords = shifted_coords * scale

    # Convert to grid indices
    indices = ((scaled_coords + grid_size / 2)).astype(int)

    # Populate grid
    for idx in indices:
        x, y, z = idx
        if 0 <= x < grid_size and 0 <= y < grid_size and 0 <= z < grid_size:
            grid[x, y, z] = 1.0  # Mark atom presence

    return grid

# Function to generate molecular fingerprints from SMILES
def generate_fingerprint(smiles, n_bits=2048):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=n_bits)
        arr = np.zeros((1,), dtype=int)
        DataStructs.ConvertToNumpyArray(fp, arr)
        return arr
    else:
        print(f"Invalid SMILES string: {smiles}")
        return np.zeros((n_bits,), dtype=int)

# Build the CNN model with drug input
def build_cnn_with_drug_input(protein_input_shape, drug_input_shape):
    # Protein input and CNN layers
    protein_input = Input(shape=protein_input_shape)
    x = layers.Conv3D(32, (3, 3, 3), activation='relu')(protein_input)
    x = layers.MaxPooling3D((2, 2, 2))(x)
    x = layers.Conv3D(64, (3, 3, 3), activation='relu')(x)
    x = layers.MaxPooling3D((2, 2, 2))(x)
    x = layers.Conv3D(128, (3, 3, 3), activation='relu')(x)
    x = layers.GlobalMaxPooling3D()(x)

    # Drug input and dense layers
    drug_input = Input(shape=(drug_input_shape,))
    drug_layer = layers.Dense(256, activation='relu')(drug_input)
    drug_layer = layers.Dense(128, activation='relu')(drug_layer)

    # Concatenate protein and drug layers
    combined = concatenate([x, drug_layer])

    # Final layers
    combined = layers.Dense(256, activation='relu')(combined)
    combined = layers.Dense(128, activation='relu')(combined)
    output = layers.Dense(1, activation='sigmoid')(combined)

    # Build model
    model = models.Model(inputs=[protein_input, drug_input], outputs=output)
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Example usage with multiple proteins and drugs

# List of protein PDB IDs
pdb_ids = ['1A2C', '1A2B', '1A4U']  # Replace with actual PDB IDs

# Corresponding SMILES strings for drugs
drug_smiles_list = [
    'CCO',          # Ethanol
    'CC(=O)O',      # Acetic acid
    'C1CCCCC1'      # Cyclohexane
]

# Fetch and voxelize multiple protein structures
protein_structures = []
for pdb_id in pdb_ids:
    try:
        structure = fetch_protein_data(pdb_id)
        protein_structures.append(structure)
    except Exception as e:
        print(f"Error fetching protein {pdb_id}: {e}")

# Voxelize proteins
voxel_grids = [voxelize_protein(structure) for structure in protein_structures]

# Convert voxel grids to NumPy arrays
X_proteins = np.array(voxel_grids).reshape(-1, 32, 32, 32, 1)

# Generate drug fingerprints
from rdkit import DataStructs

drug_fingerprints = []
for smiles in drug_smiles_list:
    fp = generate_fingerprint(smiles)
    drug_fingerprints.append(fp)

X_drugs = np.array(drug_fingerprints)

# Example labels (1 for binding, 0 for non-binding)
y_train = np.array([1, 0, 1])  # Replace with actual binding affinity labels

# Build the CNN model
protein_input_shape = (32, 32, 32, 1)  # Shape of the protein voxel grid
drug_input_shape = X_drugs.shape[1]    # Length of drug fingerprint vector
cnn_drug_model = build_cnn_with_drug_input(protein_input_shape, drug_input_shape)

# Train the model
cnn_drug_model.fit([X_proteins, X_drugs], y_train, epochs=10, batch_size=1)

# Predict for new protein-drug pair
new_pdb_id = '1A2C'  # Replace with a new PDB ID
new_smiles = 'CCN'   # Example SMILES string (Ethylamine)

# Fetch and voxelize new protein
new_structure = fetch_protein_data(new_pdb_id)
new_protein_voxel = voxelize_protein(new_structure)
new_protein_voxel = new_protein_voxel.reshape(1, 32, 32, 32, 1)

# Generate fingerprint for new drug
new_drug_fp = generate_fingerprint(new_smiles).reshape(1, -1)

# Predict binding probability
prediction = cnn_drug_model.predict([new_protein_voxel, new_drug_fp])
print(f'Predicted binding site probability for new protein-drug pair: {prediction[0][0]}')
# Save the trained model
cnn_drug_model.save('deepdrug1st.keras')  # Save your trained model

# Loading the model (optional, for later use)
from tensorflow.keras.models import load_model

# Load the model
model = load_model('deepdrug1st.keras')  # Ensure this is the correct path

# Import libraries
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.layers import Input, concatenate
from Bio.PDB import PDBList, PDBParser
from rdkit import Chem
from rdkit.Chem import AllChem
import os

# Function to fetch protein structure data from PDB using NCBI API
def fetch_protein_data(pdb_id):
    pdb_dir = './pdb_files'
    if not os.path.exists(pdb_dir):
        os.makedirs(pdb_dir)

    pdbl = PDBList()
    pdbl.retrieve_pdb_file(pdb_id, pdir=pdb_dir, file_format="pdb")

    parser = PDBParser(QUIET=True)
    structure = parser.get_structure(pdb_id, os.path.join(pdb_dir, f'pdb{pdb_id.lower()}.ent'))
    return structure

# Function to convert protein structure into voxel grids
def voxelize_protein(structure, grid_size=32, grid_spacing=1.0):
    # Initialize empty grid
    grid = np.zeros((grid_size, grid_size, grid_size))

    # Calculate center of mass to center the grid
    atom_coords = np.array([atom.get_coord() for atom in structure.get_atoms()])
    com = np.mean(atom_coords, axis=0)

    # Shift coordinates to center
    shifted_coords = atom_coords - com

    # Scale coordinates to fit the grid
    max_coord = np.max(np.abs(shifted_coords))
    scale = (grid_size / 2 - 1) / max_coord
    scaled_coords = shifted_coords * scale

    # Convert to grid indices
    indices = ((scaled_coords + grid_size / 2)).astype(int)

    # Populate grid
    for idx in indices:
        x, y, z = idx
        if 0 <= x < grid_size and 0 <= y < grid_size and 0 <= z < grid_size:
            grid[x, y, z] = 1.0  # Mark atom presence

    return grid

# Function to generate molecular fingerprints from SMILES
def generate_fingerprint(smiles, n_bits=2048):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=n_bits)
        arr = np.zeros((1,), dtype=int)
        DataStructs.ConvertToNumpyArray(fp, arr)
        return arr
    else:
        print(f"Invalid SMILES string: {smiles}")
        return np.zeros((n_bits,), dtype=int)

# Build the CNN model with drug input
def build_cnn_with_drug_input(protein_input_shape, drug_input_shape):
    # Protein input and CNN layers
    protein_input = Input(shape=protein_input_shape)
    x = layers.Conv3D(32, (3, 3, 3), activation='relu')(protein_input)
    x = layers.MaxPooling3D((2, 2, 2))(x)
    x = layers.Conv3D(64, (3, 3, 3), activation='relu')(x)
    x = layers.MaxPooling3D((2, 2, 2))(x)
    x = layers.Conv3D(128, (3, 3, 3), activation='relu')(x)
    x = layers.GlobalMaxPooling3D()(x)

    # Drug input and dense layers
    drug_input = Input(shape=(drug_input_shape,))
    drug_layer = layers.Dense(256, activation='relu')(drug_input)
    drug_layer = layers.Dense(128, activation='relu')(drug_layer)

    # Concatenate protein and drug layers
    combined = concatenate([x, drug_layer])

    # Final layers
    combined = layers.Dense(256, activation='relu')(combined)
    combined = layers.Dense(128, activation='relu')(combined)
    output = layers.Dense(1, activation='sigmoid')(combined)

    # Build model
    model = models.Model(inputs=[protein_input, drug_input], outputs=output)
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Example usage with multiple proteins and drugs

# List of protein PDB IDs
pdb_ids = ['1A2C', '1A2B', '1A4U']  # Replace with actual PDB IDs

# Corresponding SMILES strings for drugs
drug_smiles_list = [
    'CCO',          # Ethanol
    'CC(=O)O',      # Acetic acid
    'C1CCCCC1'      # Cyclohexane
]

# Fetch and voxelize multiple protein structures
protein_structures = []
for pdb_id in pdb_ids:
    try:
        structure = fetch_protein_data(pdb_id)
        protein_structures.append(structure)
    except Exception as e:
        print(f"Error fetching protein {pdb_id}: {e}")

# Voxelize proteins
voxel_grids = [voxelize_protein(structure) for structure in protein_structures]

# Convert voxel grids to NumPy arrays
X_proteins = np.array(voxel_grids).reshape(-1, 32, 32, 32, 1)

# Generate drug fingerprints
from rdkit import DataStructs

drug_fingerprints = []
for smiles in drug_smiles_list:
    fp = generate_fingerprint(smiles)
    drug_fingerprints.append(fp)

X_drugs = np.array(drug_fingerprints)

# Example labels (1 for binding, 0 for non-binding)
y_train = np.array([1, 0, 1])  # Replace with actual binding affinity labels

# Build the CNN model
protein_input_shape = (32, 32, 32, 1)  # Shape of the protein voxel grid
drug_input_shape = X_drugs.shape[1]    # Length of drug fingerprint vector
cnn_drug_model = build_cnn_with_drug_input(protein_input_shape, drug_input_shape)

# Train the model
cnn_drug_model.fit([X_proteins, X_drugs], y_train, epochs=10, batch_size=1)

# Predict for new protein-drug pair
new_pdb_id = '1A2C'  # Replace with a new PDB ID
new_smiles = 'CCN'   # Example SMILES string (Ethylamine)

# Fetch and voxelize new protein
new_structure = fetch_protein_data(new_pdb_id)
new_protein_voxel = voxelize_protein(new_structure)
new_protein_voxel = new_protein_voxel.reshape(1, 32, 32, 32, 1)

# Generate fingerprint for new drug
new_drug_fp = generate_fingerprint(new_smiles).reshape(1, -1)

# Predict binding probability
prediction = cnn_drug_model.predict([new_protein_voxel, new_drug_fp])
print(f'Predicted binding site probability for new protein-drug pair: {prediction[0][0]}')
# Save the trained model
cnn_drug_model.save('deepdrug1st.keras')  # Save your trained model

# Loading the model (optional, for later use)
from tensorflow.keras.models import load_model

# Load the model
model = load_model('deepdrug1st.keras')  # Ensure this is the correct path
# Save your trained model to Google Drive
from google.colab import drive
drive.mount('/content/drive')  # Mount Google Drive

# Create a directory for models if it doesn't exist
!mkdir -p /content/drive/MyDrive/models  # Create a folder named 'models' in your Google Drive

# Save the model
cnn_drug_model.save('/content/drive/MyDrive/models/deepdrug1st.keras')  # Save your trained model

print("Model saved successfully.")

